
# XKubeMesh orchestrate XKube objects, where each xkube object 
# is a Kubernetes resource. 
# 
# XKube object must create resources that are associated with xkube 
# at the time of creation. This includes secrets containing kubeconfig,
# ssh resources required for configuration, etc. 
#
# XKubeMesh utilizes each cluster's data, obtained from XKube object
# to configure inter-cluster coordination.
#
# Extra resources:
#  - Secret (k3s token)
#  - ProviderConfig (k3s cluster)
#
#
# List of objects:
#  - XKube (load Xkubes with its Secret containing kubeconfig)
#  - Object [Job] (Istio CA certificates and remote secrets)
#  - Object [Secret] Apply remote secrets to each cluster using ProviderConfig
#  - Helm [istio-base]
#  - Helm [Submariner] # TODO: this may be happen in the XKube?
#
#  Note: clusterName is the name of xkubes.skycluster.io
#        we need the xkubes.<cloud>.skycluter.io available within status.clusterName
#
#  List all xkube clusters (assume names are given by user)
#
#  Construct Job to generates certificates and remote secrets for all clusters (it automatically 
#    fetches the secrets by labels (skycluster.io/secret-type=k8s-connection-data)
#
#  Once done successfully (conditional), get all generated secrets (using labels
#    skycluster.io/secret-type=cluster-cacert, compare label
#    skycluster.io/cluster-name=<cluster-name>) with the names of xkube objects
#
#  Need to fetch providerconfigs.kuberenetes for all xkubes clusters    
#
#  Using kubernetes providerconfigs, generates remote secret of each cluster on 
#  all other clusters.
#
#  Creates two map: <cluster-name: []provider-cfgs> and 
#    <cluster-name>: []remote-secrets and use them below:
#
# {
#   object-kubernetes-secret{
#     remote_secret_for_s
#     providercfg_remote_t
#   } for s in cluster-names for t in cluster-names if s != t 
# }

import yaml
import json
import base64
import datetime

import helper.v1alpha1.main as helper
import provider_kubernetes.v1alpha2 as k8sv1a2
import provider_helm.v1beta1 as helmv1b1


oxr = option("params").oxr # observed composite resource
ocds = option("params")?.ocds # observed composed resources
extra = option("params")?.extraResources
# _dxr = option("params").dxr # desired composite resource
# dcds = option("params").dcds # desired composed resources

# _oxrProvPlatform = oxr.spec?.providerRef?.platform or Undefined
# _oxrProvRegion = oxr.spec?.providerRef?.region or Undefined
# _oxrProvZones = oxr.spec?.providerRef?.zones or Undefined
# _oxrProvZone = oxr.spec?.providerRef?.zones?.primary or Undefined
# _oxrAppId = oxr.spec?.applicationId or Undefined

ctx = option("params")?.ctx
assert ctx is not Undefined, "Context must be provided in the params"

_extraRes = ctx["apiextensions.crossplane.io/extra-resources"]
assert _extraRes is not Undefined, "Extra resources must be provided in the context"

_xsetup = _extraRes["XSetups"]?[0] or Undefined
assert _xsetup is not Undefined, "XSetup resource must be provided in the extra resources"

# These are secrets containing istio remote secrets for remote clusters
# They will be generated by the Job later here
_remoteSecrets = _extraRes["ClusterRemoteSecrets"] or Undefined
# assert _remoteSecrets is not Undefined, "ClusterRemoteSecrets resource must be provided in the extra resources"

_remoteK8SProviderCfgs = _extraRes["ClusterK8SProviderConfigs"] or Undefined
assert _remoteK8SProviderCfgs is not Undefined, "ClusterK8SProviderConfigs resource must be provided in the extra resources"

_remoteHelmProviderCfgs = _extraRes["ClusterHelmProviderConfigs"] or Undefined
assert _remoteHelmProviderCfgs is not Undefined, "ClusterHelmProviderConfigs resource must be provided in the extra resources"

assert oxr.spec?.localCluster?.podCidr, "Pod CIDR must be provided in the spec"
assert oxr.spec?.localCluster?.serviceCidr, "Service CIDR must be provided in the spec"

# Default (local) provider config
_k8sProvCfgName = _xsetup.status?.providerConfig?.kubernetes?.name or Undefined
_k8sMgmtClusterName = "k8s-skycluster-management"

_default_labels = {
  **oxr.metadata?.labels,
  "skycluster.io/managed-by" = "skycluster"
}

_default_annotations = {**oxr.metadata?.annotations}

_clusterNames = oxr.spec?.clusterNames or []
assert len(_clusterNames) > 0, "At least one cluster name must be provided in the spec.clusters"

_helper_cleanup_job = lambda s, c, kc, k8scfg {
  k8sv1a2.Object{
    metadata = {
      labels = _default_labels | {"skycluster.io/job-type": "cleanup-{}-{}".format(c.label, s)}
      annotations = _default_annotations | \
        helper._set_resource_name("cleanup-{}-{}".format(c.label, s)) | {
          "skycluster.io/creation-time" = "{}".format(datetime.ticks())
        }
    }
    spec =  {
      forProvider.manifest = {
        apiVersion = "batch/v1"
        kind = "Job"
        metadata = { 
          name = "cleanup-{}-{}".format(c.label, s),
          namespace = "skycluster-system",
          labels = _default_labels | {
            "skycluster.io/job-type": "cleanup-job",
            "skycluster.io/job-name": "cleanup-{}-{}".format(c.label, s)
          },
        }
        spec = {
          backoffLimit = 0
          template = {
            metadata.labels = _default_labels |{
              "skycluster.io/job-type": "istio-cluster-ca-certs"
            }
            spec = {
              serviceAccountName = "skycluster-sva"
              restartPolicy = "Never"
              volumes = [{
                  name = "work"
                  emptyDir = {}
                }, {
                  name = "script"
                  configMap = {
                    name = "script-helm-clean-up"
                    defaultMode = 0755
                  }
                }
              ]
              containers = [{
                  name = "runner"
                  image = "etesami/kubectl:latest"
                  imagePullPolicy = "Always"
                  command = ["/bin/bash","-lc","/script/run.sh"]
                  env = [{
                      name = "CHART_REPO"
                      value = c.repo
                    }, {
                      name = "CHART_NAME"
                      value = c.name
                    }, {
                      name = "CHART_VERSION"
                      value = c.version
                    },{
                      name = "CHART_NAMESPACE"
                      value = c.ns
                    }, {
                      name = "KUBECONFIG_DATA"
                      value = kc[s]?["kubeconfig"] or "local"
                    }, {
                      # space-separated K8s object references
                      name = "BLOCKING_OBJECTS"
                      value = c.blocking_obj or Undefined
                    }, {
                      name = "CLUSTERROLE_PREFIX"
                      value = c.prefix_obj
                    }
                  ]
                  volumeMounts = [{
                      name = "work"
                      mountPath = "/work"
                    }, {
                      name = "script"
                      mountPath = "/script"
                    }
                  ]
                }
              ]
            }
          }
        }
      }
      providerConfigRef = {
        name = k8scfg
      }
    }
  }
}

_helper_dummy_pod = lambda s {
  k8sv1a2.Object{
    metadata = {
      labels = _default_labels | {"skycluster.io/pod-type": "dummy-pod"}
      annotations = _default_annotations | helper._set_resource_name("dummy-pod-{}".format(s))
    }
    spec =  {
      forProvider.manifest = {
        apiVersion = "v1"
        kind = "Pod"
        metadata = { 
          name = "dummy-pod-{}".format(s),
          namespace = "kube-system",
          labels = _default_labels | {
            "component": "kube-apiserver"
            "skycluster.io/pod-type": "dummy-pod"
          },
          annotations = _default_annotations
        }
        spec = {
          restartPolicy = "Always"
          containers = [{
            name = "dummy-container"
            image = "busybox"
            command = ["sh","-c","echo \"Starting dummy pod\";\n          tail -f /dev/null"]
            args = ["--service-cluster-ip-range={}".format(_xkubesRefData[s]?.serviceCidr)]  
          }]
        }
      }
      providerConfigRef = {
        # run the pod in the local cluster and use kubeconfig to configure remote cluster
        name = _remoteProviderCfgsMaps[s]?.k8s
      }
    }
  }
}

_helper_cacerts = lambda {
  k8sv1a2.Object{
    metadata = {
      labels = _default_labels | {"skycluster.io/job-type": "istio-cluster-ca-certs"}
      annotations = _default_annotations | helper._set_resource_name("caCerts")
    }
    spec =  {
      forProvider.manifest = {
        apiVersion = "batch/v1"
        kind = "Job"
        metadata = { 
          name = "istio-cluster-ca-certs-generator",
          namespace = "skycluster-system",
          labels = _default_labels | {"skycluster.io/job-type": "istio-cluster-ca-certs"},
          annotations = _default_annotations
        }
        spec = {
          backoffLimit = 0
          template = {
            metadata.labels = _default_labels | {
              "skycluster.io/job-type": "istio-cluster-ca-certs"
            }
            spec = {
              serviceAccountName: "skycluster-sva"
              restartPolicy = "Never"
              volumes = [{
                  name = "work"
                  emptyDir = {}
                }, {
                  name = "script"
                  configMap = {
                    name = "script-istio-cluster-certs"
                    defaultMode = 0755
                  }
                }
              ]
              containers = [{
                  name = "runner"
                  image = "etesami/kubectl:latest"
                  imagePullPolicy = "IfNotPresent"
                  command = ["/bin/bash","-lc","/script/run.sh"]
                  env = [{
                      name = "NAMESPACE"
                      value = "skycluster-system"
                    }, {
                      name = "ROOT_SECRET_NAME"
                      value = "istio-root-ca"
                    }, {
                      name = "KCFG_SELECTOR"
                      value = "skycluster.io/managed-by=skycluster,skycluster.io/secret-type=k8s-connection-data"
                    }
                  ]
                  volumeMounts = [{
                      name = "work"
                      mountPath = "/work"
                    }, {
                      name = "script"
                      mountPath = "/script"
                    }
                  ]
                }
              ]
            }
          }
        }
      }
      providerConfigRef = {
        name = _k8sProvCfgName
      }
    }
  }
}

_helper_submariner_secret = lambda s, psk, apiServer, brokerCA, brokerToken {
  k8sv1a2.Object{
    metadata = {
      labels = _default_labels
      annotations = _default_annotations | {
        **helper._set_resource_name("submSec{}".format(s)),
      } 
    }
    spec = {
      forProvider.manifest = {
        apiVersion = "v1"
        kind = "Secret"
        metadata = { 
          name = "submariner-connection-secret",
          namespace = "skycluster-system",
          labels = _default_labels | {
            "skycluster.io/config-type": "connection-secret"
          },
          annotations = _default_annotations
        }
        type: "Opaque"
        stringData = {
          "values.yaml" = json.encode({
            "ipsec": {
              "psk": psk
            },
            "broker": {
              "server": apiServer,
              "namespace": "skycluster-system",
              "ca" : brokerCA,
              "token": brokerToken
            }
          })
        }
      }
      providerConfigRef = {
        name = _remoteProviderCfgsMaps[s]?.k8s
      }
    }
  }
}

_helper_subm_operator = lambda s, ch {
  helmv1b1.Release{
    metadata = {
      labels = _default_labels 
      annotations = _default_annotations | {
        **helper._set_resource_name("submOp{}".format(s))
      }
    }
    spec = {
      forProvider = {
        chart = {
          name = ch.name
          repository = ch.repo
          version = ch.version
        }
        namespace = ch.ns
        skipCreateNamespace = True
        valuesFrom = [{
          secretKeyRef = {
            # Reference to the local secret
            key = "values.yaml"
            name = "submariner-connection-secret"
            namespace = "skycluster-system"
          }
        }]
        values = {
          debug = "true",
          submariner = {
            serviceDiscovery = "false",
            cableDriver = "wireguard",
            clusterId = s,
            clusterCidr = _xkubesRefData[s]?.podCidr,
            serviceCidr = _xkubesRefData[s]?.serviceCidr,
            natEnabled = "true"
          }
        }
      }
      providerConfigRef = {
        name = _remoteProviderCfgsMaps[s]?.helm
      }
    }
  }
}

_helper_istio_base = lambda s, ch {
  helmv1b1.Release{
    metadata = {
      labels = {
        **oxr.metadata?.labels,
        "skycluster.io/managed-by": "skycluster",
      },
      annotations = {
        **oxr.metadata?.annotations,
        **helper._set_resource_name("istio-base-{}".format(s))
      }
    }
    spec = {
      forProvider = {
        chart = {
          name = ch.name
          repository = ch.repo
          version = ch.version
        }
        namespace = ch.ns
        skipCreateNamespace = False
      }
      providerConfigRef = {
        name = _remoteProviderCfgsMaps?[s]?.helm
      }
    }
  }
}

_helper_istio_operator = lambda s, ch {
  helmv1b1.Release{
    metadata = {
      labels = {
        **oxr.metadata?.labels,
        "skycluster.io/managed-by": "skycluster",
      },
      annotations = {
        **oxr.metadata?.annotations,
        **helper._set_resource_name("istiod-{}".format(s))
      }
    }
    spec = {
      forProvider = {
        chart = {
          name = ch.name
          repository = ch.repo
          version = ch.version
        }
        set = [
          {
            name = "global.meshID"
            value = "mesh1"
          },
          {
            name = "global.network"
            value = "network1"
          },
          {
            name = "global.multiCluster.clusterName"
            value = s
          }
        ]
        namespace = "istio-system"
        skipCreateNamespace = False
      }
      providerConfigRef = {
        name = _remoteProviderCfgsMaps?[s]?.helm
      }
    }
  }
}

_helper_istio_remote_sec = lambda s, t {
  k8sv1a2.Object{
    metadata = {
      labels = _default_labels | {"skycluster.io/secret-type": "remote"}
      annotations = _default_annotations | helper._set_resource_name("istio-rsec-{}-{}".format(s, t)) | {
        "skycluster.io/from-cluster": s,
        "skycluster.io/to-cluster": t
      }
    }
    spec = {
      forProvider.manifest = {
        apiVersion = "v1"
        kind = "Secret"
        metadata = {
          name = yaml.decode(base64.decode(_remoteSecretsMap[s]?.data?["remote-secret.yaml"]).replace("---",""))?.metadata?.name
          namespace = yaml.decode(base64.decode(_remoteSecretsMap[s]?.data?["remote-secret.yaml"]).replace("---",""))?.metadata?.namespace
          labels = yaml.decode(base64.decode(_remoteSecretsMap[s]?.data?["remote-secret.yaml"]).replace("---",""))?.metadata?.labels | _default_labels | {
            "skycluster.io/secret-type": "remote"
          }
          annotations = yaml.decode(base64.decode(_remoteSecretsMap[s]?.data?["remote-secret.yaml"]).replace("---",""))?.metadata?.annotations | _default_annotations
        }
        stringData = yaml.decode(base64.decode(_remoteSecretsMap[s]?.data?["remote-secret.yaml"]).replace("---",""))?.stringData
      }
      providerConfigRef = {
        name = _remoteProviderCfgsMaps[t]?.k8s
      }
    }
  }
}

#
# fetch referenced xkubes objects based on the cluster names (cloud-provider specific k8s)
#
_clusterNamesRef = [o?.Resource?.status?.clusterName for s in _clusterNames for k, obj in extra if k == s for o in obj]
# since we have the local management cluster as part of the multi-cluster setup
# we manually add the name of the local management cluster
_clusterNamesRef += [_k8sMgmtClusterName]

# construct helper maps for remote-secrets and remote-provider-configs
_remoteSecretsMap: {str:{str:any}} = {
  cn = {
      data = s.data
      name = s.metadata?.name
    } for cn in _clusterNamesRef for s in _remoteSecrets \
      if cn == s.metadata?.labels["skycluster.io/cluster-name"]
} if _remoteSecrets else Undefined

_remoteK8SKubeconfigs = {
  cn = {
    kubeconfig = p?.Resource?.data?["kubeconfig"]
  } for cn in _clusterNamesRef for p in (extra?["kconfigSecrets"] or []) \
      if cn == p?.Resource?.metadata?.labels["skycluster.io/cluster-name"]
}

_remoteK8SProviderCfgsMap = {
  cn = p.metadata?.name for cn in _clusterNamesRef for p in _remoteK8SProviderCfgs \
      if cn == p.metadata?.labels["skycluster.io/cluster-name"]
}

_remoteHelmProviderCfgsMap = {
  cn = p.metadata?.name for cn in _clusterNamesRef for p in _remoteHelmProviderCfgs \
      if cn == p.metadata?.labels["skycluster.io/cluster-name"]
}
assert len(_remoteK8SProviderCfgsMap) == len(_remoteHelmProviderCfgsMap), \
  "Remote K8S and Helm provider configs must exist for all clusters, found {} K8S and {} Helm configs."\
    .format(len(_remoteK8SProviderCfgsMap), len(_remoteHelmProviderCfgsMap))

# merge the two
_remoteProviderCfgsMaps = {
  cn = {
    k8s = _remoteK8SProviderCfgsMap[cn]
    helm = _remoteHelmProviderCfgsMap[cn]
  } for cn in _remoteHelmProviderCfgsMap
}

# Retrieve xkubes pod and service cidr
# will be used in the next step
_xkubesRefData = {
  o?.Resource?.status?.clusterName = {
    podCidr = o?.Resource?.status?.podCidr
    serviceCidr = o?.Resource?.status?.serviceCidr
  } for s in _clusterNames for k, obj in extra if k == s for o in obj
} | {
  # merge with local management cluster's data
  k = {
    podCidr = oxr.spec?.localCluster?.podCidr
    serviceCidr = oxr.spec?.localCluster?.serviceCidr
  } for k in [_k8sMgmtClusterName]
}

_items = []

######################### Cleanup Istio and Submariner ############

#
# Submariner operator, using the secret above
# We already create istio-operator for the local kubernetes cluster
# so we skip creation for the local cluster
#

_chartsSubm = {
  label = "subm"
  version = "0.20.1"
  repo = "https://submariner-io.github.io/submariner-charts/charts"
  name = "submariner-operator"
  ns = "submariner-operator"
  blocking_obj = "Submariner/submariner" # # space-separated K8s object references
  prefix_obj = "submariner"
}

_chartIstio = {
  n = {
    label = n
    version = "1.27.0"
    repo = "https://istio-release.storage.googleapis.com/charts"
    name = n
    ns = "istio-system"
    prefix_obj = "istio"
    # space-separated K8s object references
    blocking_obj = " ".join(["CustomResourceDefinition/{}".format(s) for s in [
      "wasmplugins.extensions.istio.io", 
      "destinationrules.networking.istio.io", 
      "envoyfilters.networking.istio.io", 
      "gateways.networking.istio.io", 
      "proxyconfigs.networking.istio.io", 
      "serviceentries.networking.istio.io", 
      "sidecars.networking.istio.io", 
      "virtualservices.networking.istio.io", 
      "workloadentries.networking.istio.io",
      "authorizationpolicies.security.istio.io",
      "peerauthentications.security.istio.io",
      "requestauthentications.security.istio.io",
      "telemetries.telemetry.istio.io"
    ]])
  } for n in ["base", "istiod"]
}

_items += [
  *[_helper_cleanup_job(s, _chartsSubm, _remoteK8SKubeconfigs, _k8sProvCfgName) for s in _clusterNamesRef if s != _k8sMgmtClusterName],
  *[_helper_cleanup_job(s, _chartIstio["base"], _remoteK8SKubeconfigs, _k8sProvCfgName) for s in _clusterNamesRef],
  *[_helper_cleanup_job(s, _chartIstio["istiod"], _remoteK8SKubeconfigs, _k8sProvCfgName) for s in _clusterNamesRef]
]


#
# TODO: checking job/pod status through "Object" object is not reliable. Often
# the pod/job has completed but the status is not propagated. Restarting the 
# provider-kubernetes helps but that is not an optimal solution.
# For more reliable status checking, further improvements are needed.
#
_getReadiness = lambda oc, n {
  now = datetime.ticks()
  creationTime = oc?[n]?.Resource?.annotations?["skycluster.io/creation-time"]
  t = (now - float(creationTime)) if creationTime else 0.0
  # [objects] often do not reflect the status of the completed pod,
  # so we wait for a max of 30 seconds (like best-effort cleanup)
  True if t >= 30 or str(oc?[n]?.Resource?.status?.atProvider?.manifest?.status?.succeeded) == "1" else False
}
_submCleanupReadiness = {
  "{}".format(s) = _getReadiness(ocds, "cleanup-{}-{}".format(c.label, s)) \
    for s in _clusterNamesRef for c in [_chartsSubm] if s != _k8sMgmtClusterName
} | {
  "{}".format(s) = True for s in [_k8sMgmtClusterName] for c in [_chartsSubm]
}
_istioBaseReadiness = {
  "{}".format(s) = _getReadiness(ocds, "cleanup-{}-{}".format(c, s)) \
  for s in _clusterNamesRef for c, _ in _chartIstio if c == "base"
}
_istioIstiodReadiness = {
  "{}".format(s) = _getReadiness(ocds, "cleanup-{}-{}".format(c, s)) \
  for s in _clusterNamesRef for c, _ in _chartIstio if c == "istiod"
}
_getCleanUpReadiness = lambda s {
  all_true([_submCleanupReadiness[s], _istioBaseReadiness[s], _istioIstiodReadiness[s]])
}


#
# Dummy pod for submariner issue
#
_items += [
    # This is a dummy pod that is required for submariner to detect service cidr.
    # Submariner implement a bad practice in determining service cidr where 
    # in our case it fails.
    _helper_dummy_pod(s) for s in _clusterNamesRef if s != _k8sMgmtClusterName
] if _remoteK8SKubeconfigs else []

#
# Istio Base using helm
#

#
# Ensure namespace istio-system and skycluster-system exists in the remote clusters and local
# Note: provider config for local cluster is retrieved by same filter:
# skycluster.io/config-type = k8s-connection-data through the extraResources
#
_items += [
  k8sv1a2.Object{
    metadata = {
      annotations =  helper._set_resource_name("ns-{}-{}".format(s,ns))
    }
    spec = {
      deletionPolicy = "Orphan"
      forProvider.manifest = {
        apiVersion = "v1"
        kind = "Namespace"
        metadata = {
          name = ns
          if ns == "skycluster":
            labels = {
              "istio-injection" = "enabled"
            }
        }
      }
      providerConfigRef.name = _remoteProviderCfgsMaps[s].k8s
    }
  } for s in _clusterNamesRef for ns in ["istio-system", "skycluster-system", "submariner-operator", "skycluster"] \
      if _getCleanUpReadiness(s) or ocds?["ns-{}-{}".format(s,ns)]
]


#
# Pod Generating Headscale Certificate
#
# This job creates a POD that generates secrets for each cluster. The generated secret
# contains generated CA certificates for the cluster and the remote-secret
# used by istio, stored in a secret with name pattern of <secret-name>-cacerts,
# where <secret-name> is the name of secret that contains kubeconfig data for the cluster.
#
# The generated secrets are identifiable by label 
#   "skycluster.io/secret-type=istio-cluster-cacert"
# and has a reference to its secret by
#   "skycluster.io/cluster-name=<secret-name>"
#
# The generated secrets are stored in skycluster-system namespace
# but need to be applied to the target namespace of istio-system
# when they are created in the remote clusters.
#


#
# Job: generating ca certs for each cluster, it generates certs based on secrets
# filtered by skycluster.io/secret-type=k8s-connection-data
#
_items += [
  _helper_cacerts()
] if _k8sProvCfgName or ocds?["caCerts"] else []


#
# Install Istio on remote clusters
#
# Dealing with namespace creation is tricky, as we need to ensure that the namespace exists
# before we can install Istio. 
#
# TOBE CHECKED:
#  In my experience, "skipCreateNamespace" is not reliable
#  to use since if it is set to True, the namespace is not created if it does not exist, 
#  if it is set to False, the installation may fail if cannot manage the existing ones.
#

#
# [K8S Object] Installing istio cacerts on each local cluster
#
_items += [
  # TODO: may need to introduce clean-up job
  k8sv1a2.Object{
    metadata = {
      labels = _default_labels | {"skycluster.io/secret-type": "remote"}
      annotations = _default_annotations | helper._set_resource_name("caCerts{}".format(s))
    }
    spec = {
      # TODO: delete or orphan?
      forProvider.manifest = {
        apiVersion = "v1"
        kind = "Secret"
        metadata = {
          name = "cacerts"
          namespace = "istio-system"
          labels = _default_labels
          annotations = _default_annotations
        }
        data = {
          "ca-cert.pem" = _remoteSecretsMap[s]?.data?["ca-cert.pem"]
          "ca-key.pem" = _remoteSecretsMap[s]?.data?["ca-key.pem"]
          "root-cert.pem" = _remoteSecretsMap[s]?.data?["root-cert.pem"]
          "cert-chain.pem" = _remoteSecretsMap[s]?.data?["cert-chain.pem"]
        }
      }
      providerConfigRef = {
        name = _remoteProviderCfgsMaps[s]?.k8s
      }
    }
  } for i, s in _clusterNamesRef \
     if (_getCleanUpReadiness(s) and _remoteSecretsMap and _remoteProviderCfgsMaps) or ocds?["caCerts{}".format(s)]
] 

#
# Submariner Setup
#
# Create a secret for Submariner connection on a remote cluster
# Need to get psk, brokerCA, brokerToken and apiServer, using extraResource to fetch them.
#

# Expected only one submarinerSecret
_subSecretData = extra?["submarinerSecret"]?[0]?.Resource?.data?["values.yaml"]
_subSecret = json.decode(base64.decode(_subSecretData)) if _subSecretData else Undefined
_apiServer = _subSecret?.broker?.server
_psk = _subSecret?.ipsec?.psk
_brokerCA = _subSecret?.broker?.ca
_brokerToken = _subSecret?.broker?.token

_subGate = all_true([_remoteSecretsMap, _remoteProviderCfgsMaps, _apiServer, _brokerCA, _brokerToken, _psk])

#
# Submariner Secret for remote clusters
# The local management cluster already have this secret
#
_items += [
  # submariner-connection-secret already is setup in the management cluster
  _helper_submariner_secret(s, _psk, _apiServer, _brokerCA, _brokerToken) \
    for s in _clusterNamesRef \
      if (s != _k8sMgmtClusterName and _subGate and _getCleanUpReadiness(s)) \
        or ocds?["submSec{}".format(s)] 
]

_items += [
  # We don't need to install submariner in the management cluster
  _helper_subm_operator(s, _chartsSubm) \
    for s in _clusterNamesRef \
      if (s != _k8sMgmtClusterName and _subGate and _getCleanUpReadiness(s)) \
        or ocds?["submOp{}".format(s)]
]


# ################# Istio Setup ###############

_items += [
  _helper_istio_base(s, _chartIstio["base"]) \
    for s in _clusterNamesRef \
      if (_getCleanUpReadiness(s) and _remoteProviderCfgsMaps) or ocds?["istio-base-{}".format(s)]
]

#
# Istio operator using helm
#
_items += [
  _helper_istio_operator(s, _chartIstio["istiod"]) for s in _clusterNamesRef \
    if (_getCleanUpReadiness(s) and _remoteProviderCfgsMaps) or ocds?["istiod-{}".format(s)]
]

#
# Apply remote-secret for each cluster on all other clusters
#
_items += [
  _helper_istio_remote_sec(s, t) for s in _clusterNamesRef for t in _clusterNamesRef \
    if (s != t and _getCleanUpReadiness(t) and _remoteSecretsMap and _remoteProviderCfgsMaps) \
      or ocds?["istio-rsec-{}-{}".format(s,t)]
] 



# ###################### dxr ######################

dxr = {
  **option("params").dxr,
  status = {
    clusters = [{ 
      nameRef = s
      providerConfigName = _remoteK8SProviderCfgsMap[s]
      if _remoteSecretsMap:
        secretName = _remoteSecretsMap[s]?.name or Undefined
    } for s in _clusterNamesRef]
    log = json.encode(
      {
        test = {
          s = "{}/{}/{}".format(_submCleanupReadiness[s], _istioBaseReadiness[s], _istioIstiodReadiness[s]) for s in _clusterNamesRef
        }
      }
    )
  }
}

extraItems = {
  apiVersion = "meta.krm.kcl.dev/v1alpha1"
  kind = "ExtraResources"
  requirements = {
    **{s = {
        apiVersion: "skycluster.io/v1alpha1",
        kind: "XKube",
        matchName: s
      } for s in _clusterNames if s != _k8sMgmtClusterName
    }
    **{"submarinerSecret" = {
        apiVersion: "v1",
        kind: "Secret",
        matchLabels: {
          "skycluster.io/managed-by": "skycluster",
          "skycluster.io/config-type": "connection-secret"
        }
      }
    }
    **{"kconfigSecrets" = {
        apiVersion: "v1",
        kind: "Secret",
        matchLabels: {
          "skycluster.io/managed-by": "skycluster",
          "skycluster.io/secret-type": "k8s-connection-data"
        }
      }
    }
  }
}

items = [*_items, dxr, extraItems]
