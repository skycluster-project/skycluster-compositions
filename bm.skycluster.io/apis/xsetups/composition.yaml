apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: xsetups.bm.skycluster.io
spec:
  compositeTypeRef:
    apiVersion: bm.skycluster.io/v1alpha1
    kind: XSetup
  mode: Pipeline
  pipeline:
    - step: pull-extra-resources
      functionRef:
        name: function-extra-resources
      input:
        apiVersion: extra-resources.fn.crossplane.io/v1beta1
        kind: Input
        spec:
          extraResources:
            - kind: XSetup
              into: SkySetups
              apiVersion: skycluster.io/v1alpha1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
            - kind: ConfigMap
              into: ConfigMaps
              apiVersion: v1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/config-type
                    type: Value
                    value: provider-profile
                  - key: skycluster.io/provider-platform
                    type: Value
                    value: baremetal
                  - key: skycluster.io/provider-region
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.region
    - step: resources
      functionRef:
        name: function-kcl
      input:
        apiVersion: krm.kcl.dev/v1alpha1
        kind: KCLInput
        metadata:
          name: basic
        spec:
          dependencies: |
            helper = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            provider-kubernetes = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
          source: |
            import yaml
            import json
            import base64
            import helper.v1alpha1.main as helper
            import provider_kubernetes.v1alpha2 as k8sv1a2

            oxr = option("params").oxr # observed composite resource
            ocds = option("params")?.ocds # observed composed resources
            extra = option("params")?.extraResources
            # _dxr = option("params").dxr # desired composite resource
            # dcds = option("params").dcds # desired composed resources

            _default_labels = {
              **oxr.metadata?.labels,
              "skycluster.io/managed-by" = "skycluster"
            }
            _default_annotations = {**oxr.metadata?.annotations}

            assert oxr.metadata?.labels is not Undefined, "At least one label must be specified"
            assert "skycluster.io/managed-by" in oxr.metadata.labels, "Label 'skycluster.io/managed-by' must be specified"

            ctx = option("params")?.ctx
            assert ctx is not Undefined, "Context must be provided in the params"

            _extraRes = ctx["apiextensions.crossplane.io/extra-resources"]
            assert _extraRes is not Undefined, "Extra resources must be provided in the context"

            _cms = _extraRes["ConfigMaps"][0]
            _skySetup = _extraRes["SkySetups"][0]
            _k8sProvCfgName = _skySetup.status?.providerConfig?.kubernetes?.name or Undefined

            _ns = _skySetup.spec.namespace or "skycluster-system"

            _oxrProvRegion = oxr.spec.providerRef.region
            _oxrProvZone = oxr.spec.providerRef.zones?.primary
            _oxrProvPlatform = oxr.spec.providerRef.platform
            _oxrAppId = oxr.spec.applicationId or Undefined

            assert _oxrProvRegion and _oxrProvZone and _oxrProvPlatform, "Provider region, primary zone, platform must be specified"

            assert oxr.spec?.gatewayDeviceName, "Gateway device name must be specified"

            _gatewayNodeStr = _cms.data?["gateway"] or Undefined
            _workerNodesStr = _cms.data?["worker"] or Undefined

            _gwNode = yaml.decode(_gatewayNodeStr) if _gatewayNodeStr else Undefined
            _gwWorkers = yaml.decode(_workerNodesStr) if _workerNodesStr else []

            # Only supporting one gateway node for now
            _gwNodeName = oxr.spec?.gatewayDeviceName
            _workerNodeNames = oxr.spec?.workerDeviceNames or []

            # Fetch node spec
            _gwNodeSpec = _gwNode[_gwNodeName] \
              if _gwNode and _gwNodeName and _gwNodeName in _gwNode else Undefined

            _workerNodeSpecs = [_gwWorkers[n] for n in _workerNodeNames \
              if _gwWorkers and n in _gwWorkers] \
                if _workerNodeNames else []


            _subnetCidr = _gwNodeSpec?.privateIp
            _subnetCidrOctets = _subnetCidr.split(".")
            _subnetCidrFirst = _subnetCidrOctets[0]
            _subnetCidrSecond = _subnetCidrOctets[1]
            _subnetCidrThird = _subnetCidrOctets[2]
            _subnetCidr = "{}.{}.{}.0/24".format(_subnetCidrFirst, _subnetCidrSecond, _subnetCidrThird)


            # Retrieve secret containing the private key for gateway and workers
            _gwPrivateSecretName = _gwNodeSpec?.auth?.privateKeySecretRef?.name
            _gwPrivateSecretKey = _gwNodeSpec?.auth?.privateKeySecretRef?.key
            # Encrypted private key:

            _gwSecrets = extra?["bmPrivateKeySecrets"]
            _gwSecretData = [_sec.Resource.data for _sec in _gwSecrets \
              if _sec.Resource.metadata?.name == _gwPrivateSecretName] \
                if _gwSecrets and _gwPrivateSecretName else []

            _gwPrivateKeyB64 = _gwSecretData?[0]?[_gwPrivateSecretKey] or Undefined
            # Decrypted private key
            _defaultPrivateKey = base64.decode(_gwPrivateKeyB64) if _gwPrivateKeyB64 else Undefined

            _items = []

            #
            # For gateway node, we create a secret and provider config
            #
            _gwSSHGate = all_true([_gwNodeSpec?.publicIp, _defaultPrivateKey, _k8sProvCfgName])
            _items += [
              # _helper_secret_remote = lambda s, ip, user, pvKeyB64
              _helper_secret_remote("gw", _gwNodeSpec.publicIp, _gwNodeSpec.auth.username, _gwPrivateKeyB64)
            ] if _gwSSHGate or ocds?["sec-remote-ssh-gw"] else []

            _gwSSHSecretName = ocds?["sec-remote-ssh-gw"]?.Resource?.status?.atProvider?.manifest?.metadata?.name
            _items += [
              # _helper_provider_cfg = lambda s, ip, sshSecName
              _helper_provider_cfg("gw", _gwNodeSpec.publicIp, _gwSSHSecretName)
            ] if _gwSSHSecretName or ocds?["ssh-pcfg-gw"] else []

            # 
            # We create secrets and provider configs for worker nodes as well
            # 
            _workerSSHGates = {
              n[0] = all_true([n[1]?.privateIp, _defaultPrivateKey, _k8sProvCfgName]) for n in zip(_workerNodeNames, _workerNodeSpecs)
            }

            # Create SSH secrets for worker nodes
            _items += [
              _helper_secret_remote(n[0], n[1].privateIp, n[1].auth.username, _gwPrivateKeyB64)
              for n in zip(_workerNodeNames, _workerNodeSpecs) \
                if _workerSSHGates[n[0]] or ocds?["sec-remote-ssh-{}".format(n[0])]
            ]

            # Create SSH provider configs for worker nodes
            _workerSSHSecretNames = {
              n = ocds?["sec-remote-ssh-{}".format(n)]?.Resource?.status?.atProvider?.manifest?.metadata?.name \
                for n in _workerNodeNames
            }
            _items += [
              _helper_provider_cfg(n[0], n[1].privateIp, _workerSSHSecretNames[n[0]])
              for n in zip(_workerNodeNames, _workerNodeSpecs) \
                if _workerSSHSecretNames[n[0]] or ocds?["ssh-pcfg-{}".format(n[0])]
            ]


            extraItems = {
              apiVersion = "meta.krm.kcl.dev/v1alpha1"
              kind = "ExtraResources"
              requirements = {
                **{"bmPrivateKeySecrets" = {
                    apiVersion: "v1",
                    kind: "Secret",
                    # we cannot use matchName because the secret is namespaced
                    # hence we filter by label instead and check the name later
                    matchLabels = {
                      "skycluster.io/managed-by" = "skycluster",
                      "skycluster.io/secret-type" = "onpremise-keypair"
                    }
                }}
              }
            }

            dxr = {
              **option("params").dxr,
              status = {
                log = json.encode(_workerSSHGates)
                subnetCidr = _subnetCidr,
                gateway = {
                  publicIp = _gwNodeSpec?.publicIp,
                  privateIp = _gwNodeSpec?.privateIp,
                  username = _gwNodeSpec?.auth?.username,
                }
                auth = {
                  secretName = _gwPrivateSecretName or Undefined
                  # privateKey = _defaultPrivateKey or Undefined
                } if _defaultPrivateKey else Undefined
              }
            }

            # Collect all resources into a list for output
            items = [*_items, dxr, extraItems]


            # 
            # Create SSH secret for a DeviceNode
            # 
            _helper_secret_remote = lambda s, ip, user, pvKeyB64 {
              k8sv1a2.Object{
                "metadata": {
                  labels = _default_labels
                  annotations = _default_annotations | {
                    **helper._set_resource_name("sec-remote-ssh-{}".format(s)),
                  },
                },
                spec = {
                  forProvider = {
                    manifest = {
                      apiVersion: "v1",
                      kind: "Secret",
                      metadata: {
                        name: "ssh-bm-{}-{}".format(_oxrProvRegion.lower(), ip),
                        namespace: _ns,
                        labels: _default_labels,
                        annotations: _default_annotations,
                      },
                      type = "Opaque",
                      stringData = {
                        config = json.encode({
                          username = user
                          password = ""
                          hostIP = ip
                          hostPort = "22"
                          privateKey = pvKeyB64
                    })}},
                  }
                  providerConfigRef.name = _k8sProvCfgName
                }
              }
            }

            # 
            # Create SSH ProviderConfig for a DeviceNode
            # 
            _helper_provider_cfg = lambda s, ip, sshSecName {
              k8sv1a2.Object{
                "metadata" = {
                  labels = _default_labels
                  annotations = _default_annotations | {
                    **helper._set_resource_name("ssh-pcfg-{}".format(s)),
                  },
                },
                spec = {
                  references = [{
                    # TODO: When object is deleted, the providerconfig remains
                    # Manual deletion of provider config does not remove the finalizer on the secret
                    # The owner of secret still remains waiting for secret to be removed.
                    dependsOn = {
                      apiVersion = "v1"
                      kind = "Secret"
                      name = "ssh-bm-{}-{}".format(_oxrProvRegion.lower(), ip),
                      namespace = _ns
                    }
                  }]
                  deletionPolicy = "Delete"
                  forProvider = {
                    manifest = {
                      apiVersion = "ssh.crossplane.io/v1alpha1",
                      kind = "ProviderConfig",
                      metadata = {
                        name = "ssh-bm-{}-{}".format(_oxrProvRegion.lower(), ip),
                        namespace = _ns,
                        labels = _default_labels,
                        annotations = _default_annotations,
                      },
                      spec = {
                        credentials = {
                          source = "Secret"
                          secretRef = {
                            name = sshSecName
                            namespace = _ns,
                            key = "config"
                    }}}},
                  },
                  providerConfigRef.name = _k8sProvCfgName
                }
              }
            }
    - step: crossplane-contrib-function-auto-ready
      functionRef:
        name: function-auto-ready
