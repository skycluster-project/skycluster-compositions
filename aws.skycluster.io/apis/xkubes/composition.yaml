apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: xkubes.aws.skycluster.io
spec:
  compositeTypeRef:
    apiVersion: aws.skycluster.io/v1alpha1
    kind: XKube
  mode: Pipeline
  pipeline:
    - step: extra-resources
      functionRef:
        name: function-extra-resources
      input:
        apiVersion: extra-resources.fn.crossplane.io/v1beta1
        kind: Input
        spec:
          extraResources:
            - kind: ProviderConfig
              into: ProviderConfigs
              apiVersion: aws.upbound.io/v1beta1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
            - kind: XSetup
              into: SkySetups
              apiVersion: skycluster.io/v1alpha1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
            - kind: XSetup
              into: XSetup
              apiVersion: aws.skycluster.io/v1alpha1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/provider-platform
                    type: Value
                    value: aws
                  - key: skycluster.io/provider-region
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.region
                  - key: skycluster.io/provider-zone
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.zones.primary
                  - key: skycluster.io/application-id
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.applicationId
            - kind: Secret
              into: ConnectionSecrets
              apiVersion: v1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/config-type
                    type: Value
                    value: connection-secret
    - step: resources
      functionRef:
        name: function-kcl
      input:
        apiVersion: krm.kcl.dev/v1alpha1
        kind: KCLInput
        metadata:
          name: basic
        spec:
          dependencies: |
            provider-aws = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            provider-helm = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            provider-kubernetes = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
            helper = { git = "https://github.com/skycluster-project/kcl-modules",version = "0.0.1" }
          source: |+
            import json
            import yaml
            import crypto
            import helper.v1alpha1.main as helper
            import provider_aws.eks.v1beta1 as eksv1beta1
            import provider_aws.eks.v1beta2 as eksv1beta2
            import provider_aws.iam.v1beta1 as iamv1beta1
            import provider_aws.ec2.v1beta1 as ec2v1beta1
            import provider_helm.v1beta1 as helmv1beta1
            import provider_kubernetes.v1alpha1 as k8sv1alpha1

            oxr = option("params")?.oxr
            assert oxr.metadata?.labels is not Undefined, "At least one label must be specified"
            assert "skycluster.io/managed-by" in oxr.metadata.labels, "Label 'skycluster.io/managed-by' must be specified"
            ocds = option("params")?.ocds

            ctx = option("params")?.ctx
            assert ctx is not Undefined, "Context must be provided in the params"

            _oxrProvRegion = oxr.spec.providerRef.region
            _oxrProvZone = oxr.spec.providerRef.zones.primary
            _oxrProvPlatform = oxr.spec.providerRef.platform
            _oxrAppId = oxr.spec.providerRef.applicationId or Undefined
            _oxrServiceCidr = oxr.spec.serviceCidr or Undefined

            assert _oxrProvRegion and _oxrProvZone and _oxrProvPlatform, \
              "Provider region, primary zone, platform must be specified"
            assert _oxrServiceCidr, "Service CIDR must be specified in the oxr spec"

            _extraRes = ctx["apiextensions.crossplane.io/extra-resources"]
            assert _extraRes is not Undefined, "Extra resources must be provided in the context"
            _provCfg = _extraRes["ProviderConfigs"][0]
            _skySetup = _extraRes["SkySetups"][0]
            _xSetup = _extraRes["XSetup"][0]
            _conSecret = _extraRes["ConnectionSecrets"][0]
            _ns = "skycluster-system"

            _defaults = {
              deletionPolicy = "Delete"
              providerConfigRef.name = _provCfg.metadata.name
            }

            _items = []

            _items += [
              iamv1beta1.Role {
                metadata = {
                  labels = {
                    **oxr.metadata?.labels,
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                    "skycluster.io/iam-role" = "controlplane"
                  }
                  annotations = {
                    **oxr.metadata?.annotations,
                    **helper._set_resource_name("controlplaneRole"),
                    **helper._is_paused_label(oxr.metadata.labels)
                  }
                }
                spec: _defaults | {
                  forProvider = {
                    forceDetachPolicies = True
                    managedPolicyArns = [
                      "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"
                    ]
                    assumeRolePolicy = json.encode({
                      Version = "2012-10-17",
                      Statement = [
                        {
                          Effect = "Allow",
                          Principal = {
                            Service = ["eks.amazonaws.com"]
                          },
                          Action = ["sts:AssumeRole"]
                        }
                      ]
                    })
                  }
                }
              },

              eksv1beta2.Cluster {
                metadata = {
                  labels = {
                    **oxr.metadata?.labels
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId)
                  }
                  annotations = {
                    **oxr.metadata?.annotations,
                    **helper._set_resource_name("kubernetesCluster"),
                    **helper._is_paused_label(oxr.metadata.labels)
                  }
                }
                spec: _defaults | {
                  forProvider = {
                    region = _oxrProvRegion
                    version = "1.32"
                    accessConfig = {
                      authenticationMode = "API_AND_CONFIG_MAP"
                      bootstrapClusterCreatorAdminPermissions = True
                    }
                    kubernetesNetworkConfig = {
                      serviceIpv4Cidr = _oxrServiceCidr
                    }
                    roleArnSelector = {
                      matchControllerRef = True
                      matchLabels = {
                        "skycluster.io/iam-role" = "controlplane"
                      }
                    }
                    vpcConfig = {
                      endpointPrivateAccess = True
                      securityGroupIdSelector = {
                        matchLabels = {
                          **helper._filter_default_labels(oxr.metadata.labels)
                        }
                      }
                      subnetIdSelector = {
                        matchLabels = {
                          **helper._filter_labels(oxr.metadata.labels, ["provider-platform", "provider-region", "application-id"]) 
                        }
                      }
                    }
                  }
                }
              }
            ]

            _connectionSecretNamespace = _ns

            _items += [
              eksv1beta1.ClusterAuth{
                metadata = {
                  labels = {
                    **oxr.metadata?.labels,
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId)
                  }
                  annotations = {
                    **oxr.metadata?.annotations,
                    **helper._set_resource_name("kubernetesClusterAuth"),
                    **helper._is_paused_label(oxr.metadata.labels)
                  }
                }
                spec: _defaults | {
                  forProvider = {
                    region = _oxrProvRegion
                    clusterNameSelector.matchControllerRef = True
                  }
                  writeConnectionSecretToRef = {
                    name = "{}-eks".format(oxr.metadata.uid)
                    namespace = _connectionSecretNamespace
                  }
                }
              }
            ] if helper._ready(ocds?["kubernetesCluster"]) or ocds?["kubernetesClusterAuth"] else []


            _nodeGroups = oxr.spec.nodeGroups
            _items += [
              # The public node group is used to create nodes acting as gateways for the cluster.
              eksv1beta2.NodeGroup{
                metadata = {
                  labels = {
                    **oxr.metadata?.labels,
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                    "skycluster.io/public-subnet" = "true" if ng.publicAccess else "false"
                  }
                  annotations = {
                    **oxr.metadata?.annotations,
                    **helper._set_resource_name("nodeGroup{}{}".format("Public" if ng.publicAccess else "Private", i)),
                    **helper._is_paused_label(oxr.metadata.labels)
                  }
                }
                spec: _defaults | {
                  initProvider = {
                    scalingConfig = {
                      desiredSize = ng.nodeCount or 1
                    }
                  }
                  forProvider = {
                    region = _oxrProvRegion
                    clusterNameSelector.matchControllerRef = True
                    nodeRoleArnSelector = {
                      matchControllerRef = True
                      matchLabels = {
                        "skycluster.io/iam-role" = "nodegroup"
                      }
                    }
                    scalingConfig = {
                      minSize = ng.autoScaling?.minSize or 1
                      maxSize = (ng.autoScaling?.maxSize if not ng.publicAccess else 1) or 10
                    }
                    labels = {
                      **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId)
                      **{
                        "skycluster.io/public-subnet" = "true"
                        "submariner.io/gateway" = "true"
                      } if ng.publicAccess else {
                        "skycluster.io/public-subnet" = "false"
                      },
                    }
                    remoteAccess = {
                      ec2SshKey = _xSetup?.status?.keypair?.id
                      sourceSecurityGroupIdSelector = {
                        matchLabels = {
                          **helper._filter_default_labels(oxr.metadata.labels)
                          "skycluster.io/secgroup-type" = "default",
                        }
                      }
                    }
                    instanceTypes = ng.instanceTypes or ["t3.medium"]
                    subnetIdSelector.matchLabels = {
                      **helper._filter_labels(oxr.metadata.labels, ["provider-platform", "provider-region", "application-id"])
                      "skycluster.io/public-subnet" = "true" if ng.publicAccess else "false"
                    }
                  }
                }
              }
              for i, ng in _nodeGroups
            ] if helper._ready(ocds?["vpc-cni-addon"]) or ocds?["nodeGroupPublic"] else []

            _items += [
              iamv1beta1.Role{
                metadata = {
                  labels = {
                    **oxr.metadata?.labels,
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                    "skycluster.io/iam-role" = "nodegroup"
                  }
                  annotations = {
                    **oxr.metadata?.annotations,
                    **helper._set_resource_name("nodegroupRole"),
                    **helper._is_paused_label(oxr.metadata.labels)
                  }
                }
                spec: _defaults | {
                  forProvider = {
                    forceDetachPolicies = True
                    managedPolicyArns = [
                      "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy"
                      "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"
                      "arn:aws:iam::aws:policy/service-role/AmazonEBSCSIDriverPolicy"
                      "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
                    ]
                    assumeRolePolicy = json.encode({
                      Version = "2012-10-17",
                      Statement = [
                        {
                          Effect = "Allow",
                          Principal = {
                            Service = ["ec2.amazonaws.com"]
                          },
                          Action = ["sts:AssumeRole"]
                        }
                      ]
                    })
                  }
                }
              }
            ]

            _principalArn = oxr.spec?.principalArn or Undefined

            _items += [
              eksv1beta1.AccessEntry{
                # force recreate when principalArn changes
                metadata = {
                  labels = {
                    **oxr.metadata?.labels,
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                  }
                  annotations = {
                    **oxr.metadata?.annotations,
                    **helper._set_resource_name(crypto.sha256("accessEntry-{}".format(_principalArn))),
                    **helper._is_paused_label(oxr.metadata.labels)
                  }
                }
                spec: _defaults | {
                  forProvider = {
                    region = _oxrProvRegion
                    clusterNameSelector = {
                      matchControllerRef = True
                    }
                    type = "STANDARD"
                    principalArn = _principalArn
                  }
                }
              },
              eksv1beta1.AccessPolicyAssociation{
                # force recreate when principalArn changes
                metadata = {
                  labels = {
                    **oxr.metadata?.labels,
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                  }
                  annotations = {
                    **oxr.metadata?.annotations,
                    **helper._set_resource_name(crypto.sha256("accessPolicyAssociation-{}".format(_principalArn))),
                    **helper._is_paused_label(oxr.metadata.labels)
                  }
                }
                spec: _defaults | {
                  forProvider = {
                    region = _oxrProvRegion
                    accessScope: {
                      type: "cluster"
                    }
                    clusterNameSelector .matchControllerRef = True
                    policyArn: "arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy"
                    principalArnSelector = {
                      matchControllerRef = True
                    }
                  }
                }
              }
            ] if _principalArn else []


            _items += [
              eksv1beta1.Addon{
                metadata = {
                  labels = {
                    **oxr.metadata?.labels,
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                  }
                  annotations = {
                    **oxr.metadata?.annotations,
                    **helper._set_resource_name("vpc-cni-addon"),
                    **helper._is_paused_label(oxr.metadata.labels)
                  }
                }
                spec: _defaults | {
                  forProvider = {
                    region = _oxrProvRegion
                    addonName = "vpc-cni"
                    clusterNameSelector.matchControllerRef = True
                    # see https://github.com/aws/amazon-vpc-cni-k8s/blob/master/README.md for different options
                    configurationValues: '{"env": {"AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG":"false"}}'
                  }
                }
              }
            ] if helper._ready(ocds?["kubernetesClusterAuth"]) or ocds?["vpc-cni-addon"] else []


            _nodeGroupReady = any_true(
              [helper._ready(ocds?["nodeGroup{}{}".format("Public" if ng.publicAccess else "Private", i)] ) for i, ng in _nodeGroups]
            )
            _items += [
              eksv1beta1.Addon{
                metadata = {
                  labels = {
                    **oxr.metadata?.labels,
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                  }
                  annotations = {
                    **oxr.metadata?.annotations,
                    **helper._set_resource_name("aws-ebs-csi-driver-addon"),
                    **helper._is_paused_label(oxr.metadata.labels)
                  }
                }
                spec: _defaults | {
                  forProvider = {
                    region = _oxrProvRegion
                    addonName = "aws-ebs-csi-driver"
                    clusterNameSelector.matchControllerRef = True
                    configurationValues = '{"defaultStorageClass": {"enabled": true}}'
                  }
                }
              }
            ] if _nodeGroupReady or ocds?["aws-ebs-csi-driver-addon"] else []


            _items += [
              eksv1beta1.Addon{
                metadata = {
                  labels = {
                    **oxr.metadata?.labels,
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
                  }
                  annotations = {
                    **oxr.metadata?.annotations,
                    **helper._set_resource_name("eks-pod-identity-agent-addon"),
                    **helper._is_paused_label(oxr.metadata.labels)
                  }
                }
                spec: _defaults | {
                  forProvider = {
                    region = _oxrProvRegion
                    addonName = "eks-pod-identity-agent"
                    clusterNameSelector.matchControllerRef = True
                  }
                }
              }
            ] if _nodeGroupReady or ocds?["eks-pod-identity-agent"] else []

            _providerConfigTypes = ["helm", "kubernetes"]
            _items += [{
              apiVersion = "{}.crossplane.io/{}".format(t, "v1beta1" if t == "helm" else "v1alpha1")
              kind = "ProviderConfig"
              metadata = {
                # name = "skycluster"
                annotations = {
                  **helper._set_resource_name("providerConfig{}".format(t.capitalize()))
                  "krm.kcl.dev/ready" = "True"
                }
              }
              spec.credentials = {
                secretRef = {
                  name = "{}-eks".format(oxr.metadata.uid)
                  namespace = _connectionSecretNamespace
                  key = "kubeconfig"
                }
                source = "Secret"
              }
            } for t in _providerConfigTypes if helper._ready(ocds?["kubernetesClusterAuth"]) or ocds?["providerConfig{}".format(t.capitalize())]]

            _items += [{
              apiVersion: "meta.krm.kcl.dev/v1alpha1"
              kind: "CompositeConnectionDetails"
              data: {
                kubeconfig = option("params")?.ocds?["kubernetesClusterAuth"]?.ConnectionDetails?.kubeconfig
              } if ocds?["kubernetesClusterAuth"] else {}
            }]


            _items += [
              k8sv1alpha1.ProviderConfig {
                metadata = {
                  labels = {"skycluster.io/managed-by": "skycluster"}
                  annotations = {
                      **oxr.metadata?.annotations,
                      **helper._set_resource_name("eksClusterConfig"),
                      "krm.kcl.dev/ready": "True"
                  }
                }
                spec = {
                  credentials = {
                    source = "Secret"
                    secretRef = {
                      namespace = _ns
                      name = "{}-eks".format(oxr.metadata.uid)
                      key = "kubeconfig"
                    }
                  }
                }
              }
            ] if helper._ready(ocds?["kubernetesCluster"]) or ocds?["eksClusterConfig"] else []
            _items += [
                helmv1beta1.ProviderConfig {
                metadata = {
                  labels = {"skycluster.io/managed-by": "skycluster"}
                  annotations = {
                      **oxr.metadata?.annotations,
                      **helper._set_resource_name("eksClusterConfigHelm"),
                      "krm.kcl.dev/ready": "True"
                  }
                }
                spec = {
                  credentials = {
                    source: "Secret"
                    secretRef = {
                      namespace = _ns
                      name = "{}-eks".format(oxr.metadata.uid)
                      key = "kubeconfig"
                    }
                  }
                }
              }
            ] if helper._ready(ocds?["kubernetesCluster"]) or ocds?["eksClusterConfigHelm"] else []


            _k8sProvCfgName = ocds?["eksClusterConfig"]?.Resource?.metadata?.name 
            _helmProvCfgName = ocds?["eksClusterConfigHelm"]?.Resource?.metadata?.name 
            _clusterName = ocds?["kubernetesCluster"]?.Resource?.metadata?.name 
            _vpcCidr = _xSetup?.status?.vpc?.cidrBlock

            _depReady = helper._ready(ocds?["kubernetesCluster"]) and ocds?["eksClusterConfigHelm"]

            _items += [
              helmv1beta1.Release{
                metadata = {
                  labels = {
                    **oxr.metadata?.labels,
                    "skycluster.io/managed-by": "skycluster",
                  },
                  annotations = {
                    **oxr.metadata?.annotations,
                    **helper._set_resource_name("submarinerClientCluster")
                  }
                }
                spec = {
                  forProvider = {
                    chart = {
                      name = "submariner-operator"
                      repository = "https://submariner-io.github.io/submariner-charts/charts"
                      version = "0.20.1"
                    }
                    namespace = "submariner-operator"
                    skipCreateNamespace = False
                    valuesFrom = [{
                        secretKeyRef = {
                          key = "values.yaml"
                          name = _conSecret.metadata.name 
                          namespace = _ns if _ns else "skycluster-system"
                        }
                    }]
                    values = {
                      submariner = {
                          serviceDiscovery = "false",
                          cableDriver = "wireguard",
                          clusterId = _clusterName,
                          clusterCidr = _vpcCidr,
                          serviceCidr = _oxrServiceCidr,
                          natEnabled = "true"
                          debug = "true"
                      }   
                    }
                  }
                  providerConfigRef = {
                    name = _helmProvCfgName
                  }
                }
              }
            ] if _depReady or ocds?["submarinerClientCluster"] else []



            # ?.Resource?.metadata?.name 

            _nodeGroupNames = ["nodeGroup{}{}".format("Public" if ng.publicAccess else "Private", i) for i, ng in _nodeGroups]
            _sshSecGroupIds = [ocds?[_n]?.Resource?.status?.atProvider?.resources?[0]?.remoteAccessSecurityGroupId for _n in _nodeGroupNames]
            _udpPortDefaults = [{"fromPort" = port, "toPort" = port} for port in [4500 4800]]

            _items += [
              ec2v1beta1.SecurityGroup{
                metadata = {
                  annotations = {
                    **helper._set_resource_name("sshSecGroup{}".format(_i) ),
                    "crossplane.io/external-name" = _s
                  }
                },
                spec = {
                  managementPolicies = ["Observe"]
                  forProvider = {
                    region = _oxrProvRegion
                  }
                  providerConfigRef = {
                    name = _provCfg.metadata.name,
                  },
                }
              } for _i, _s in _sshSecGroupIds
            ] if all_true(_sshSecGroupIds) else []

            _items += [
              ec2v1beta1.SecurityGroupRule{
                metadata = {
                  labels = {
                    **oxr.metadata?.labels
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId) 
                  }
                  annotations = {
                    **oxr.metadata?.annotations,
                    **helper._set_resource_name("secGroupRuleUdp{}-{}-{}".format(_i, port.fromPort, port.toPort)),
                    **helper._is_paused_label(oxr.metadata.labels),
                  }
                },
                spec = {
                  forProvider = {
                    region = _oxrProvRegion,
                    securityGroupId = _s
                    protocol = "udp",
                    fromPort = port.fromPort,
                    toPort = port.toPort,
                    type = "ingress",
                    cidrBlocks = [ "0.0.0.0/0" ],
                  },
                  providerConfigRef = {
                    name = _provCfg.metadata.name,
                  },
                }
              } for _i, _s in _sshSecGroupIds for port in _udpPortDefaults 
            ] if all_true(_sshSecGroupIds) else []

            _items += [
              ec2v1beta1.SecurityGroupRule{
                metadata = {
                  labels = {
                    **oxr.metadata?.labels
                    **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId)
                  }
                  annotations = {
                    **oxr.metadata?.annotations,
                    **helper._set_resource_name("secGroupRule{}".format(_i)),
                    **helper._is_paused_label(oxr.metadata.labels),
                  }
                },
                spec = {
                  forProvider = {
                    region = _oxrProvRegion,
                    securityGroupId = _s
                    protocol = "icmp",
                    fromPort = -1,
                    toPort = -1,
                    type = "ingress",
                    cidrBlocks = ["0.0.0.0/0"],
                  },
                  providerConfigRef = {
                    name = _provCfg.metadata.name,
                  },
                }
              } for _i, _s in _sshSecGroupIds
            ] if all_true(_sshSecGroupIds) else []

            _dummy_log = {
              nodeGroupNames = ",".join(_nodeGroupNames),
              sshSecGroupIds = ",".join(_sshSecGroupIds),
              sshGroupNames = ",".join(["sshSecGroup{}".format(_i) for _i, _s in _sshSecGroupIds])
            }


            dxr = {
              **option("params").dxr,
              status.log = yaml.encode(_dummy_log),
            }


            items =  [*_items, dxr]


    - step: function-auto-ready
      functionRef:
        name: function-auto-ready

