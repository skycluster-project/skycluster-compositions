apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: xkubes.os.skycluster.io
spec:
  compositeTypeRef:
    apiVersion: os.skycluster.io/v1alpha1
    kind: XKube
  mode: Pipeline
  pipeline:
    - step: extra-resources
      functionRef:
        name: function-extra-resources
      input:
        apiVersion: extra-resources.fn.crossplane.io/v1beta1
        kind: Input
        spec:
          extraResources:
            - kind: ProviderConfig
              into: ProviderConfigs
              apiVersion: openstack.crossplane.io/v1beta1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/provider-region
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.region
            - kind: XSetup
              into: SkySetups
              apiVersion: skycluster.io/v1alpha1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
            - kind: XSetup
              into: XSetup
              apiVersion: os.skycluster.io/v1alpha1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/provider-platform
                    type: Value
                    value: openstack
                  - key: skycluster.io/provider-region
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.region
                  - key: skycluster.io/provider-zone
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.zones.primary
                  - key: skycluster.io/application-id
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.applicationId
            - kind: ConfigMap
              into: InitScripts
              apiVersion: v1
              type: Selector
              selector:
                minMatch: 1
                maxMatch: 100
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/script-type
                    type: Value
                    value: cloud-init
            - kind: ConfigMap
              into: InitScriptsSSH
              apiVersion: v1
              type: Selector
              selector:
                minMatch: 1
                maxMatch: 100
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/script-type
                    type: Value
                    value: sshtask
    - step: resources
      functionRef:
        name: function-kcl
      input:
        apiVersion: krm.kcl.dev/v1alpha1
        kind: KCLInput
        metadata:
          name: basic
        spec:
          dependencies: |
            helper = { git = "https://github.com/skycluster-project/kcl-modules", version = "0.0.1" }
            provider-kubernetes = { git = "https://github.com/skycluster-project/kcl-modules", version = "0.0.1" }
            provider-helm = { git = "https://github.com/skycluster-project/kcl-modules", version = "0.0.1" }
            provider-openstack = { git = "https://github.com/skycluster-project/kcl-modules", version = "0.0.1" }
          source: |2-

            import yaml
            import base64
            import crypto
            import json
            import helper.v1alpha1.main as helper
            import provider_kubernetes.v1alpha2 as k8sv1a2

            oxr = option("params").oxr # observed composite resource
            ocds = option("params")?.ocds # observed composed resources

            ctx = option("params")?.ctx
            assert ctx is not Undefined, "Context must be provided in the params"

            _extraRes = ctx["apiextensions.crossplane.io/extra-resources"]
            assert _extraRes is not Undefined, "Extra resources must be provided in the context"

            _xsetup = _extraRes["XSetup"][0]
            assert _xsetup is not Undefined, "XSetup must be provided in the extra resources"

            _skySetup = _extraRes["SkySetups"][0]
            assert _skySetup is not Undefined, "SkySetup must be provided in the extra resources"

            _provCfg = _extraRes["ProviderConfigs"]?[0]
            assert _provCfg is not Undefined, "ProviderConfig must be provided in the extra resources"

            _initScripts = _extraRes["InitScripts"]
            assert _initScripts is not Undefined, "Init scripts must be provided in the extra resources"

            _initScriptsSSH = _extraRes["InitScriptsSSH"]
            assert _initScriptsSSH is not Undefined, "Init scripts SSH must be provided in the extra resources"

            _oxrName = oxr.metadata.name
            _oxrProvRegion = oxr.spec.providerRef.region
            _oxrProvZone = oxr.spec.providerRef.zones.primary
            _oxrProvPlatform = oxr.spec.providerRef.platform
            _oxrAppId = oxr.spec.applicationId or Undefined
            _oxrAnnotations = oxr.metadata.annotations

            assert _oxrProvRegion and _oxrProvZone and _oxrProvPlatform, \
              "Provider region, primary zone, platform must be specified"

            _k8sProviderCfgName = _skySetup.status?.providerConfig?.kubernetes?.name

            _defaults = {
              providerConfigRef = {
                name = _provCfg.metadata.name
              },
            }

            _default_labels = {
              **oxr.metadata?.labels,
              **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
            }

            _default_annotations = {
              **oxr.metadata?.annotations,
              **helper._is_paused_label(oxr.metadata.labels),
            }

            _filter_objects: (any, str) -> [any] = lambda _objects, role {
              [{
                name = o.metadata?.name
                object = o
              } for o in _objects if o and o.metadata?.labels["skycluster.io/instance-role"] == role]
            }

            _select_scripts: (any, [str]) -> any = lambda _scripts, names {
              _selected = [s.data for s in _scripts for n in names if s and n.lower() == s.metadata?.labels["skycluster.io/script-init"]]
              assert len(_selected) == 1, "Expected exactly one script, found {}".format(len(_selected))
              _selected[0]
            }

            _merge = lambda ll, new_ll {ll | new_ll}
            _replace: (str, str, str, str) -> str = lambda s:str, p:str, r:str, z:str {
              s.replace("__PROVIDERPLATFORM__", p)\
                .replace("__REGION__", r)\
                  .replace("__ZONE__", z)
            }
            _replace_with: (str, str, str) -> str = lambda s:str, k:str, v:str {
              s.replace(k, v)
            }

            _ns = "skycluster-system"
            _ud = oxr.spec?.userData or Undefined
            _scripts = ["k3s-controller"]
            _defaultUserData = yaml.decode(helper._select_init_scripts(_initScripts, _scripts)) or Undefined
            _userDataCtrl = helper._append_init_scripts([_defaultUserData] + ([yaml.decode(_ud)] if _ud else []))

            # This is cloud-init
            _userDataCtrl = _replace(
              _userDataCtrl, _oxrProvPlatform, _oxrProvRegion, _oxrProvZone
            ) if _userDataCtrl else Undefined

            # This is config map
            _k3sCtrlScript = _select_scripts(_initScriptsSSH, ["k3s-controller-check"]) or {}
            _k3sAgentScript: {str:str} = _select_scripts(_initScriptsSSH, ["k3s-agent"]) or {}

            _agentProbeScript = _replace(
              _k3sAgentScript["probeScript"], _oxrProvPlatform, _oxrProvRegion, _oxrProvZone
            ) if _k3sAgentScript else Undefined
            _agentEnsureScript = _replace(
              _k3sAgentScript["ensureScript"], _oxrProvPlatform, _oxrProvRegion, _oxrProvZone
            ) if _k3sAgentScript else Undefined


            _items = []

            _ctrlNodeGrp = [n for n in oxr.spec.nodeGroups if n and n.role == "control-plane" ]
            _maxNodeCount = 1
            _maxNodeGrpCount = 1

            # ng<hash>c<I> = {
            #   nodeGrpHash = <hash>
            #   count = <I>
            #   <additional map str:str>
            # }
            _ctrlObjData = {
              "ng{}c{}".format(crypto.md5(str(ng)), j): {
                nodeGrpHash = crypto.md5(str(ng))
                count = str(j)
              } for i, ng in _ctrlNodeGrp[:_maxNodeGrpCount] \
                  for j in range(0, min(_maxNodeCount, ng.nodeCount))
            }
            # Add additional map str:str
            _ctrlObjData = {
              k = _merge(
                v, 
                {
                  sshProviderCfg = ocds?[k]?.Resource?.status?.providerConfig?.kubernetes?.name
                  sshTaskName = "st{}c{}".format(v.nodeGrpHash, v.count)
                  sshGate = all_true([
                    _agentProbeScript, 
                    _agentEnsureScript, 
                    ocds?[k]?.Resource?.status?.providerConfig?.kubernetes?.name
                  ])
                  token = ocds?["st{}c{}".format(v.nodeGrpHash, v.count)]?.Resource?.status?.atProvider?.observed?.fields?.token
                  kubeconfig_encoded = ocds?["st{}c{}".format(v.nodeGrpHash, v.count)]?.Resource?.status?.atProvider?.observed?.fields?.kubeconfig
                  privateIp = ocds?[k]?.Resource?.status?.network?.privateIp
                  publicIp = ocds?[k]?.Resource?.status?.network?.publicIp
                  secretName = "sc{}c{}".format(v.nodeGrpHash, v.count)
                  secretGate = all_true([
                    ocds?["st{}c{}".format(v.nodeGrpHash, v.count)]?.Resource?.status?.atProvider?.observed?.fields?.token,
                    ocds?["st{}c{}".format(v.nodeGrpHash, v.count)]?.Resource?.status?.atProvider?.observed?.fields?.kubeconfig,
                    ocds?[k]?.Resource?.status?.network?.privateIp
                  ])
                }
              ) for k, v in _ctrlObjData
            }


            # ctrl xinstance(s)
            # Multi controller is not yet supported, we capture the first nodegroup 
            # specified for control-plane and create an instance for it (ignoring nodeCount)
            _items += [
              {
                "apiVersion" = "skycluster.io/v1alpha1",
                "kind" = "XInstance",
                "metadata" = {
                  labels = _default_labels | {
                    "skycluster.io/instance-role" = "controller"
                  }
                  annotations = _default_annotations | {
                    # We fetch the first nodeGroup, and we hash the nodeGroup, so if the first nodeGroup
                    # changed, the resource is re-created subsequently
                    **helper._set_resource_name("ng{}c{}".format(crypto.md5(str(ng)), j)),
                  },
                },
                "spec" = {
                  "applicationId" = _oxrAppId,
                  "ipForwarding" = True,
                  "image" = "ubuntu-24.04",
                  "flavor" = ng.instanceType,
                  "publicIp" = True,
                  "providerRef" = {
                    "platform" = _oxrProvPlatform,
                    "region" = _oxrProvRegion,
                    "zone" = _oxrProvZone
                  },
                  "userData" = _userDataCtrl
                }
              } for i, ng in _ctrlNodeGrp[:_maxNodeGrpCount] \
                  for j in range(0, min(_maxNodeCount, ng.nodeCount))
            ] if _ctrlNodeGrp else []


            # ctrl ssh connection sshtask
            # Multi controller is not yet supported
            _items += [
              {
                apiVersion = "ssh.crossplane.io/v1alpha1"
                kind = "SSHTask"
                metadata = {
                  labels = _default_labels
                  annotations = _default_annotations | {
                    **helper._set_resource_name(cv.sshTaskName),
                  },
                },
                spec = {
                  providerConfigRef.name = cv.sshProviderCfg
                  forProvider = {
                    scripts = {
                      probeScript.inline = _k3sCtrlScript?["probeScript"]
                      ensureScript.inline = _k3sCtrlScript?["ensureScript"]
                    }
                    observe = {
                      refreshPolicy = "Always"
                      capture = "both"
                      "map" = [{
                          from = "network.ip"
                          to = "ip"
                        }, {
                          from = "kubeconfig.token"
                          to = "token"
                        }, {
                          from = "kubeconfig.encoded"
                          to = "kubeconfig"
                        }
                      ]
                    }
                    execution = {
                      sudo = True
                      shell = "/bin/bash -euo pipefail"
                      timeoutSeconds = 600
                      maxAttempts = 30
                    }
                    artifactPolicy.capture = "both"    
                  }
                }
              } for c, cv in _ctrlObjData if cv.sshGate
            ]


            # ctrl ssh connection secret
            # Multi controller is not yet supported
            _items += [
              k8sv1a2.Object{
                metadata = {
                  labels = _default_labels
                  annotations = _default_annotations | {
                    # We fetch the first nodeGroup, and we hash the nodeGroup, so if the first nodeGroup
                    # changed, the resource is re-created subsequently
                    **helper._set_resource_name(cv.secretName),
                  },
                },
                spec = {
                  forProvider = {
                    manifest = {
                      apiVersion = "v1",
                      kind = "Secret",
                      metadata = {
                        name = "k3s-{}-{}-{}".format(_oxrProvPlatform.lower(), _oxrProvRegion.lower(), cv.privateIp),
                        namespace = _ns,
                        labels = _default_labels | {
                          "skycluster.io/secret-type" = "k3s-connection-data"
                        },
                        annotations = _default_annotations,
                      },
                      spec = {
                        "type" = "Opaque",
                        data = {
                          "kubeconfig" = cv.kubeconfig_encoded,
                          "token" = base64.encode(cv.token)
                        }
                      }
                    },
                  },
                  providerConfigRef.name = _k8sProviderCfgName
                }
              } for c, cv in _ctrlObjData if cv.secretGate
            ]



            # ###################### Agents ######################

            # There may be multiple controller, however, we only support single controller
            # This means we use one IP and Token corresponding to one controller, even 
            # if user has specified multiple node groups for controller with node count > 1

            _ctrlIp = [v.privateIp for k, v in _ctrlObjData][0]
            _ctrlIpPublic = [v.publicIp for k, v in _ctrlObjData][0]
            _ctrlToken = [v.token for k, v in _ctrlObjData][0]
            _ctrlKubeconfig_enc = [v.kubeconfig_encoded for k, v in _ctrlObjData][0]

            _agentNodeGroups = [n for n in oxr.spec.nodeGroups if n and n.role == "worker" ]

            _agentObjData = {
              "ng{}c{}".format(crypto.md5(str(ng)), j): {
                nodeGrpHash = crypto.md5(str(ng))
                count = str(j)
                publicAccess = ng.publicAccess
                instanceType = ng.instanceType
              } for i, ng in _agentNodeGroups for j in range(0, ng.nodeCount)
            }
            # Add additional map str:str
            _agentObjData = {
              k = _merge(
                v, 
                {
                  sshProviderCfg = ocds?[k]?.Resource?.status?.providerConfig?.kubernetes?.name
                  sshTaskName = "st{}c{}".format(v.nodeGrpHash, v.count)
                  sshGate = all_true([
                    _ctrlToken,
                    _ctrlIp,
                    ocds?[k]?.Resource?.status?.providerConfig?.kubernetes?.name,
                    ocds?[k]?.Resource?.status?.network?.privateIp
                  ])
                  privateIp = ocds?[k]?.Resource?.status?.network?.privateIp
                  publicIp = ocds?[k]?.Resource?.status?.network?.publicIp
                }
              ) for k, v in _agentObjData
            }

            # Agent xinstance(s)
            _items += [
              {
                "apiVersion" = "skycluster.io/v1alpha1",
                "kind" = "XInstance",
                "metadata" = {
                  labels = _default_labels | {
                    "skycluster.io/instance-role" = "worker"
                  }
                  annotations = _default_annotations | {
                    **helper._set_resource_name(k),
                  },
                },
                "spec" = {
                  "applicationId" = _oxrAppId,
                  "ipForwarding" = True,
                  "image" = "ubuntu-24.04",
                  "flavor" = v.instanceType,
                  "publicIp" = v.publicAccess,
                  "providerRef" = {
                    "platform" = _oxrProvPlatform,
                    "region" = _oxrProvRegion,
                    "zone" = _oxrProvZone
                  },
                }
              } for k, v in _agentObjData
            ]


            # agent ssh connection sshtask
            _items += [
              {
                apiVersion = "ssh.crossplane.io/v1alpha1"
                kind = "SSHTask"
                metadata = {
                  labels = _default_labels
                  annotations = _default_annotations | {
                    **helper._set_resource_name(v.sshTaskName),
                  },
                },
                spec = {
                  providerConfigRef.name = v.sshProviderCfg
                  forProvider = {
                    scripts = {
                      # TODO: change with agent script
                      probeScript.inline = _agentProbeScript
                      ensureScript.inline = _agentEnsureScript
                    }
                    observe = {
                      refreshPolicy = "Always"
                      # TODO: change with agent script
                      capture = "both"
                      "map" = [{
                          from = "k3s.version"
                          to = "k3sVersion"
                        }, {
                          from = "k3s.agentActive"
                          to = "agentActive"
                        }, {
                          from = "k3s.screenExists"
                          to = "screenExists"
                        }
                      ]
                    }
                    execution = {
                      sudo = True
                      shell = "/bin/bash -euo pipefail"
                      timeoutSeconds = 600
                      maxAttempts = 30
                      env = [
                        {
                          name = "__K3STOKEN__",
                          value = _ctrlToken,
                        },
                        {
                          name = "__K3SHOSTIP__",
                          value = _ctrlIp
                        }
                      ]
                    }
                    artifactPolicy.capture = "both"    
                  }
                }
              } for k, v in _agentObjData if v.sshGate
            ] 



            # ###################### dxr ######################

            dxr = {
              **option("params").dxr,
              status = {
                if _ctrlKubeconfig_enc:
                  kubeconfig = _ctrlKubeconfig_enc
                if _ctrlToken:
                  token = _ctrlToken
                if _ctrlIp or _ctrlIpPublic:
                  controller = [{
                    privateIp = _ctrlIp or Undefined
                    publicIp = _ctrlIpPublic or Undefined
                  }]
                # if _k8sProviderCfgName:
                #   providerConfig = {
                #     kubernetes.name = _k8sProviderCfgName
                #   }
                # log = json.encode({
                #   "__K3STOKEN__" = _ctrlToken
                #   "__K3SHOSTIP__" = _ctrlIp
                #   ctrl = _ctrlObjData
                #   agents = _agentObjData
                # })
              }
            }

            items = [*_items, dxr]
    - step: function-auto-ready
      functionRef:
        name: function-auto-ready
