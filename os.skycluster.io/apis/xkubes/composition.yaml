apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: xkubes.os.skycluster.io
spec:
  compositeTypeRef:
    apiVersion: os.skycluster.io/v1alpha1
    kind: XKube
  mode: Pipeline
  pipeline:
    - step: extra-resources
      functionRef:
        name: function-extra-resources
      input:
        apiVersion: extra-resources.fn.crossplane.io/v1beta1
        kind: Input
        spec:
          extraResources:
            - kind: ProviderConfig
              into: ProviderConfigs
              apiVersion: openstack.crossplane.io/v1beta1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/provider-region
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.region
            - kind: XSetup
              into: SkySetups
              apiVersion: skycluster.io/v1alpha1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
            - kind: XSetup
              into: XSetup
              apiVersion: os.skycluster.io/v1alpha1
              type: Selector
              selector:
                maxMatch: 1
                minMatch: 1
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/provider-platform
                    type: Value
                    value: openstack
                  - key: skycluster.io/provider-region
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.region
                  - key: skycluster.io/provider-zone
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.providerRef.zones.primary
                  - key: skycluster.io/application-id
                    type: FromCompositeFieldPath
                    valueFromFieldPath: spec.applicationId
            - kind: ConfigMap
              into: InitScripts
              apiVersion: v1
              type: Selector
              selector:
                minMatch: 1
                maxMatch: 100
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/script-type
                    type: Value
                    value: cloud-init
            - kind: ConfigMap
              into: InitScriptsSSH
              apiVersion: v1
              type: Selector
              selector:
                minMatch: 1
                maxMatch: 100
                matchLabels:
                  - key: skycluster.io/managed-by
                    type: Value
                    value: skycluster
                  - key: skycluster.io/script-type
                    type: Value
                    value: sshtask
    - step: resources
      functionRef:
        name: function-kcl
      input:
        apiVersion: krm.kcl.dev/v1alpha1
        kind: KCLInput
        metadata:
          name: basic
        spec:
          dependencies: |
            helper = { git = "https://github.com/skycluster-project/kcl-modules", version = "0.0.1" }
            provider-kubernetes = { git = "https://github.com/skycluster-project/kcl-modules", version = "0.0.1" }
            provider-helm = { git = "https://github.com/skycluster-project/kcl-modules", version = "0.0.1" }
            provider-openstack = { git = "https://github.com/skycluster-project/kcl-modules", version = "0.0.1" }
          source: |2-

            import yaml
            import base64
            import json
            import helper.v1alpha1.main as helper
            import provider_openstack.v1alpha1 as opv1a1
            import provider_helm.v1beta1 as helmv1b1
            import provider_kubernetes.v1alpha2 as k8sv1a2

            oxr = option("params").oxr # observed composite resource
            ocds = option("params")?.ocds # observed composed resources

            ctx = option("params")?.ctx
            assert ctx is not Undefined, "Context must be provided in the params"

            _extraRes = ctx["apiextensions.crossplane.io/extra-resources"]
            assert _extraRes is not Undefined, "Extra resources must be provided in the context"

            _xsetup = _extraRes["XSetup"][0]
            assert _xsetup is not Undefined, "XSetup must be provided in the extra resources"

            _skySetup = _extraRes["SkySetups"][0]
            assert _skySetup is not Undefined, "SkySetup must be provided in the extra resources"

            _provCfg = _extraRes["ProviderConfigs"]?[0]
            assert _provCfg is not Undefined, "ProviderConfig must be provided in the extra resources"

            _xSetup = _extraRes["XSetup"][0]
            assert _xSetup is not Undefined, "XSetup must be provided in the extra resources"

            _initScripts = _extraRes["InitScripts"]
            assert _initScripts is not Undefined, "Init scripts must be provided in the extra resources"

            _initScriptsSSH = _extraRes["InitScriptsSSH"]
            assert _initScriptsSSH is not Undefined, "Init scripts SSH must be provided in the extra resources"

            _oxrName = oxr.metadata.name
            _oxrProvRegion = oxr.spec.providerRef.region
            _oxrProvZone = oxr.spec.providerRef.zones.primary
            _oxrProvPlatform = oxr.spec.providerRef.platform
            _oxrAppId = oxr.spec.applicationId or Undefined
            _oxrAnnotations = oxr.metadata.annotations

            _k8sProviderCfgName = _skySetup.status?.providerConfig?.kubernetes?.name

            _defaults = {
              providerConfigRef = {
                name = _provCfg.metadata.name
              },
            }

            _default_labels = {
              **oxr.metadata?.labels,
              **helper._set_default_labels(_oxrProvPlatform, _oxrProvRegion, _oxrProvZone, _oxrAppId),
            }

            _default_annotations = {
              **oxr.metadata?.annotations,
              **helper._is_paused_label(oxr.metadata.labels),
            }

            assert _oxrProvRegion and _oxrProvZone and _oxrProvPlatform, \
              "Provider region, primary zone, platform must be specified"

            _ns = "skycluster-system"
            _ud = oxr.spec?.userData or Undefined
            _scripts = ["k3s-controller"]
            _defaultUserData = yaml.decode(helper._select_init_scripts(_initScripts, _scripts)) or Undefined
            _userDataCtrl = helper._append_init_scripts([_defaultUserData] + ([yaml.decode(_ud)] if _ud else []))

            _userDataCtrl = _userDataCtrl.replace("__PROVIDERPLATFORM__", _oxrProvPlatform)
            _userDataCtrl = _userDataCtrl.replace("__REGION__", _oxrProvRegion)
            _userDataCtrl = _userDataCtrl.replace("__ZONE__", _oxrProvZone)

            _items = []

            _controllerNodes = [n for n in oxr.spec.nodeGroups if n and n.role == "control-plane" ]
            _items += [
              {
                "apiVersion" = "skycluster.io/v1alpha1",
                "kind" = "XInstance",
                "metadata" = {
                  labels = _default_labels
                  annotations = _default_annotations | {
                    **helper._set_resource_name("ctrlNode{}".format(i)),
                  },
                },
                "spec" = {
                  "applicationId" = _oxrAppId,
                  "ipForwarding" = True,
                  "image" = "ubuntu-24.04",
                  "flavor" = n.instanceType,
                  "publicIp" = True,
                  "providerRef" = {
                    "platform" = _oxrProvPlatform,
                    "region" = _oxrProvRegion,
                    "zone" = _oxrProvZone
                  },
                  "userData" = _userDataCtrl
                }
              } for i, n in _controllerNodes[:1] # Multi controller is not yet supported
            ] if _controllerNodes else []

            # Multi controller is not yet supported
            _sshProviderCfgName = ocds?["ctrlNode0"]?.Resource?.status?.providerConfig?.kubernetes?.name

            _select_scripts: (any, [str]) -> any = lambda _scripts, names {
                _selected = [s.data for s in _scripts for n in names if s and n.lower() == s.metadata?.labels["skycluster.io/script-init"]]
                assert len(_selected) == 1, "more than one scripts found, expected only one."
                yamls = [s for s in _selected if s][0]
            }

            _sshScript = _select_scripts(_initScriptsSSH, ["k3s-controller-check"]) or Undefined
            _scriptGate = all_true([_sshScript?["probeScript"], _sshScript?["ensureScript"], _sshProviderCfgName])

            _items += [{
              apiVersion = "ssh.crossplane.io/v1alpha1"
              kind = "SSHTask"
              metadata = {
                labels = _default_labels
                annotations = _default_annotations | {
                  **helper._set_resource_name("ctrlScript"),
                },
              },
              spec = {
                providerConfigRef.name = _sshProviderCfgName
                forProvider = {
                  scripts = {
                    probeScript.inline = _sshScript?["probeScript"]
                    ensureScript.inline = _sshScript?["ensureScript"]
                  }
                  observe = {
                    refreshPolicy = "Always"
                    capture = "both"
                    "map" = [{
                        from = "network.ip"
                        to = "ip"
                      }, {
                        from = "kubeconfig.token"
                        to = "token"
                      }, {
                        from = "kubeconfig.encoded"
                        to = "kubeconfig"
                      }
                    ]
                  }
                  execution = {
                    sudo = True
                    shell = "/bin/bash -euo pipefail"
                    timeoutSeconds = 600
                    maxAttempts = 30
                    # env = [
                    #   {INLINE_VAR = "FOO"}
                    # ]
                  }
                  artifactPolicy.capture = "both"    
                }
              }
            }] if _scriptGate or ocds["ctrlScript"] else []

            _token = ocds?["ctrlScript"]?.Resource?.status?.atProvider?.observed?.fields?.token
            _kubeconfig_encoded = ocds?["ctrlScript"]?.Resource?.status?.atProvider?.observed?.fields?.kubeconfig
            _ctrlPrivateIp = ocds?["ctrlScript"]?.Resource?.status?.network?.privateIp
            _ctrlPublicIp = ocds?["ctrlScript"]?.Resource?.status?.network?.publicIp
            _secretGate = all_true([_token, _kubeconfig_encoded, _ctrlPrivateIp])

            _items += [k8sv1a2.Object{
              metadata = {
                labels = _default_labels
                annotations = _default_annotations | {
                  **helper._set_resource_name("sshConnSecret"),
                },
              },
              spec = {
                forProvider = {
                  manifest = {
                    apiVersion = "v1",
                    kind = "Secret",
                    metadata = {
                      name = "k3s-{}-{}-{}".format(_oxrProvPlatform.lower(), _oxrProvRegion.lower(), _ctrlPrivateIp),
                      namespace = _ns,
                      labels = _default_labels | {
                        "skycluster.io/secret-type" = "k3s-connection-data"
                      },
                      annotations = _default_annotations,
                    },
                    spec = {
                      "type" = "Opaque",
                      data = {
                        "kubeconfig" = _kubeconfig_encoded,
                        "token" = base64.encode(_token)
                      }
                    }
                  },
                },
                providerConfigRef.name = _k8sProviderCfgName
              }
            }] if _secretGate or ocds["sshConnSecret"] else []

            dxr = {
              **option("params").dxr,
              status = {
                if _ctrlPrivateIp or _ctrlPublicIp:
                  network = {
                    privateIp = _ctrlPrivateIp
                    publicIp = _ctrlPublicIp
                  }
                if _kubeconfig_encoded: 
                  kubeconfig = _kubeconfig_encoded
                if _token:
                  token = _token
                if _k8sProviderCfgName:
                  providerConfig = {
                    kubernetes.name = _k8sProviderCfgName
                  }
                log = json.encode({
                  len1 = len(_controllerNodes[:1])
                  ctrlNodes = _controllerNodes[:1]
                })
              }
            }

            items = [*_items, dxr]
    - step: function-auto-ready
      functionRef:
        name: function-auto-ready
